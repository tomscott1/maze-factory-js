var c={generateSquares:(a,r)=>new Promise(async n=>{let s=[];for(let u=0;u<r;u++)for(let p=0;p<a;p++)s.push({location:[p,u],pathNorth:!1,pathEast:!1,pathSouth:!1,pathWest:!1,visited:!1});let i=1,t=0,e=0,o=[[0,-1],[1,0],[0,1],[-1,0]],l=[];for(s[e*r+t].visited=!0,l.push([t,e]);i<a*r;){[t,e]=l[l.length-1];let u=[];if(e>0&&!s[(e-1)*a+t].visited&&u.push(0),t<a-1&&!s[e*a+(t+1)].visited&&u.push(1),e<r-1&&!s[(e+1)*a+t].visited&&u.push(2),t>0&&!s[e*a+(t-1)].visited&&u.push(3),u.length==0)l.pop();else{switch(u[Math.floor(Math.random()*u.length)]){case 0:s[(e-1)*r+t].visited=!0,s[(e-1)*r+t].pathSouth=!0,s[e*r+t].pathNorth=!0,l.push([t,e-1]);break;case 1:s[e*r+(t+1)].visited=!0,s[e*r+(t+1)].pathWest=!0,s[e*r+t].pathEast=!0,l.push([t+1,e]);break;case 2:s[(e+1)*r+t].visited=!0,s[(e+1)*r+t].pathNorth=!0,s[e*r+t].pathSouth=!0,l.push([t,e+1]);break;case 3:s[e*r+(t-1)].visited=!0,s[e*r+(t-1)].pathEast=!0,s[e*r+t].pathWest=!0,l.push([t-1,e]);break}i++}}n(s)}),generateHexagons:(a,r)=>new Promise(async n=>{let s=[];for(let u=0;u<a;u++)for(let p=0;p<r;p++)s.push({location:[p,u],pathNorthWest:!1,pathNorth:!1,pathNorthEast:!1,pathSouthWest:!1,pathSouth:!1,pathSouthEast:!1,visited:!1});let i=1,t=0,e=0,o=[];s[e*a+t].visited=!0,o.push([t,e]);let l=(u,p)=>{let[f,v]=u;switch(p){case 0:return(v-1)*a+f}};for(;i<r*a;){[t,e]=o[o.length-1];let u=[];if(e>0&&!s[l([t,e],0)].visited&&u.push(0),t>0&&(t%2==1||e!=0)&&!s[(e-1+t%2)*r+(t-1)].visited&&u.push(1),t<r-1&&(t%2==1||e!=0)&&!s[(e-1+t%2)*r+(t+1)].visited&&u.push(2),e<a-1&&!s[(e+1)*r+t].visited&&u.push(3),t>0&&(t%2==0||e!==a-1)&&!s[(e+t%2)*r+(t-1)].visited&&u.push(4),t<r-1&&(t%2==0||e!==a-1)&&!s[(e+t%2)*r+(t+1)].visited&&u.push(5),u.length==0)o.pop();else{switch(u[Math.floor(Math.random()*u.length)]){case 0:s[(e-1)*a+t].visited=!0,s[(e-1)*a+t].pathSouth=!0,s[e*a+t].pathNorth=!0,o.push([t,e-1]);break;case 1:s[(e-1+t%2)*a+(t-1)].visited=!0,s[(e-1+t%2)*a+(t-1)].pathSouthEast=!0,s[e*a+t].pathNorthWest=!0,o.push([t-1,e-1+t%2]);break;case 2:s[(e-1+t%2)*a+(t+1)].visited=!0,s[(e-1+t%2)*a+(t+1)].pathSouthWest=!0,s[e*a+t].pathNorthEast=!0,o.push([t+1,e-1+t%2]);break;case 3:s[(e+1)*a+t].visited=!0,s[(e+1)*a+t].pathNorth=!0,s[e*a+t].pathSouth=!0,o.push([t,e+1]);break;case 4:s[(e+t%2)*a+(t-1)].visited=!0,s[(e+t%2)*a+(t-1)].pathNorthEast=!0,s[e*a+t].pathSouthWest=!0,o.push([t-1,e+t%2]);break;case 5:s[(e+t%2)*a+(t+1)].visited=!0,s[(e+t%2)*a+(t+1)].pathNorthWest=!0,s[e*a+t].pathSouthEast=!0,o.push([t+1,e+t%2]);break}i++}}n(s)})};var b={buildMaze:(a,r)=>{if(isNaN(r)||isNaN(a))throw new Error("[buildMaze] height and width must be valid numbers");r=r|0,a=a|0;let n=[];for(let s=0;s<r;s++)n.push(Array.from({length:a},()=>Math.round(Math.random())));return n},generateBacktrack:(a,r,n)=>{switch(n){case"squares":return c.generateSquares(a,r);case"hexagons":return c.generateHexagons(a,r)}}};export{b as default};
