var n={generate:(u,t)=>{let a=[];for(let s=0;s<t;s++)for(let p=0;p<u;p++)a.push({location:[p,s],pathNorth:!1,pathEast:!1,pathSouth:!1,pathWest:!1,visited:!1});let o=1,e=0,r=0,i=[[0,-1],[1,0],[0,1],[-1,0]],l=[];for(a[r*t+e].visited=!0,l.push([e,r]);o<u*t;){[e,r]=l[l.length-1];let s=[];if(r>0&&!a[(r-1)*t+e].visited&&s.push(0),e<u-1&&!a[r*t+(e+1)].visited&&s.push(1),r<t-1&&!a[(r+1)*t+e].visited&&s.push(2),e>0&&!a[r*t+(e-1)].visited&&s.push(3),s.length==0)l.pop();else{switch(s[Math.floor(Math.random()*s.length)]){case 0:a[(r-1)*t+e].visited=!0,a[(r-1)*t+e].pathSouth=!0,a[r*t+e].pathNorth=!0,l.push([e,r-1]);break;case 1:a[r*t+(e+1)].visited=!0,a[r*t+(e+1)].pathWest=!0,a[r*t+e].pathEast=!0,l.push([e+1,r]);break;case 2:a[(r+1)*t+e].visited=!0,a[(r+1)*t+e].pathNorth=!0,a[r*t+e].pathSouth=!0,l.push([e,r+1]);break;case 3:a[r*t+(e-1)].visited=!0,a[r*t+(e-1)].pathEast=!0,a[r*t+e].pathWest=!0,l.push([e-1,r]);break}o++}}return a}};var d={buildMaze:(u,t)=>{if(isNaN(t)||isNaN(u))throw new Error("[buildMaze] height and width must be valid numbers");t=t|0,u=u|0;let a=[];for(let o=0;o<t;o++)a.push(Array.from({length:u},()=>Math.round(Math.random())));return a},generateBacktrack:(u,t)=>n.generate(u,t)};export{d as default};
